#!/usr/bin/env python
from __future__ import print_function
import os
import imp
import sys
import argparse
import logging

from zag import Sequence
from zag.predicate import *
from zag.graph import Graph

def build_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument("workflow",
        help="Workflow file to use")

    parser.add_argument("--log-file",
        dest="logFile", 
        help="If provided, logs to the provided file")

    subparsers = parser.add_subparsers(dest="command")
    run = subparsers.add_parser("run", help="Runs workflow")

    run.add_argument("--stage",
        nargs="+",
        help="Run the specific stages")

    run.add_argument("--tags",
        nargs="+",
        help="Run the tags specified")

    run.add_argument("--exclude-tags",
        dest='excludeTags',
        nargs="+",
        help="Excludes the tag from running")

    run.add_argument("--set",
        nargs="+",
        type=lambda x: x.split('=', 1),
        help="Provide a `Key=Value` to override the setting `Key` in the config")

    p = subparsers.add_parser("list", help="List Stages")

    p.add_argument("--stages",
        action="store_true",
        help="Lists stages")

    p.add_argument("--tags",
        action="store_true",
        help="Lists all tags")

    return parser

def setupLogging(fn=None, sout=sys.stdout, loglevel=logging.INFO):
    # To a file and to stdout
    fmt = "%(asctime)s %(name)s %(levelname)s - %(message)s"

    kwargs = dict(format=fmt, level=loglevel)
    if fn is not None:
        kwargs['filename'] = fn

    logging.basicConfig(**kwargs)
    if sout is not None:
        logging.root.addHandler(logging.StreamHandler(sout))

def build_predicate(args):
    p = []
    if args.tags is not None:
        p.append(AllTags(set(args.tags)))

    if args.excludeTags is not None:
        p.append(Not(AnyTags(args.excludeTags)))

    if args.stage is not None:
        p.append(StageNames(args.stage))

    if len(p) == 0:
        return All()

    if len(p) == 1:
        return p[0]

    return And(p)

def build_config(args):
    settings = {
        "PATH": os.path.dirname(os.path.abspath(args.workflow))
    }
    if args.set is not None:
        for k, v in args.set:
            settings[k] = v

    return settings

def run(args, workflow):
    graph = Graph()
    stages = {}
    config = build_config(args)
    for workflow in workflow.workflows:
        workflow = workflow.derive_config(config)
        for stage in workflow.resolve_stages():
            stages[stage.name] = stage
            graph.add_node(stage.name)
            for inbound in stage.depends_on:
                graph.add_edge(inbound, stage.name)

    predicate = build_predicate(args)
    for name in graph.toposort():
        stage = stages[name]
        print(stage.tags)
        if predicate.evaluate(stage):
            logging.info("Running stage %s", stage.name)
            stage.run()
        else:
            logging.info("Skipping stage %s", stage.name)

def list_cmd(args, workflow):
    names = set()
    tags = set()
    for workflow in workflow.workflows:
        workflow = workflow.derive_config({}, False)
        for stage in workflow.resolve_stages():
            names.add(stage.name)
            tags.update(stage.tags)

    if args.stages:
        print("Stages")
        print("------")
        for name in sorted(names):
            print(" -", name)

        print()

    if args.tags:
        print("Tags")
        print("------")
        for tag in sorted(tags):
            print(" -", tag)


def main(args):
    setupLogging(args.logFile)
    workflow = imp.load_source('workflow', args.workflow)

    if args.command == 'run':
        run(args, workflow)
    if args.command == 'list':
        list_cmd(args, workflow)
    
if __name__ == '__main__':
    main(build_parser().parse_args())
